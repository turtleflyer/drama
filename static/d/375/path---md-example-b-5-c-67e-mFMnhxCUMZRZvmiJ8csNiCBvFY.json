{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>Examples of drama library use</h1>\n<h3>Example of Tic-tac-toe game</h3>\n<pre><code class=\"language-javascript\">// Define the class of cells that the board of tic-tac-toe game consists of\nclass Cell {\n  constructor() {\n    this.node = createCell();\n  }\n}\n\n// interpretTarget property of the parameter passed to\n// defineRoutine defines the way to reach the DOM element of\n// event targets\ndefineRoutine({ interpretTarget: e => e.node });\n\n// Define the messages strings\nconst cellMarkedMessage = 'The cell is already set';\nconst gameOverMessage = 'Game is over';\nconst winMessages = ['X won', 'O won'];\n\n// Define the names of methods that mark cells as X and O\nconst turns = ['markX', 'markO'];\n\n// Add methods to the Cell class that mark a cell as X and\n// O, method that marks a cell as a part of a wining line,\n// and one that resets a cell to the empty state\nObject.assign(Cell.prototype, {\n  [turns[0]]: markX,\n  [turns[1]]: markO,\n  markAsWin,\n  resetCell,\n});\n\n// Build the board of the game\nconst gameMatrix = buildMatrix(Cell);\n\n// Define the RoleSet containing empty cells (in the\n// beginning of the game all cells are empty)\nconst emptyCells = new RoleSet(gameMatrix);\n\n// Define a function keeping the record of marked cells (for\n// each type of marks)\nfunction keepState(cell, filledCells) {\n  const cellN = gameMatrix.indexOf(cell);\n  return [...filledCells, cellN].sort((a, b) => a - b);\n}\n\n// Define two empty RoleSet's for X and O\nconst xAndOs = turns.map((turn, i) => {\n  const set = new RoleSet();\n  // Define action for the event when a new element is being\n  // added to RoleSet\n  setActionOnAddElement(\n    set,\n    (() => {\n      // Keep the record of marked cells in closure\n      let filledCells = [];\n      return ({ target, roleSet }) => {\n        // Reset the record when the first element is added\n        if (roleSet.size === 1) {\n          filledCells = [];\n        }\n\n        // Mark the cell\n        target[turn]();\n\n        // Add the cell to the record\n        filledCells = keepState(target, filledCells);\n\n        // Check if the state of win exists\n        const possibleWin = analyzePossibleWin(filledCells);\n\n        // If analyzePossibleWin returns an array of cells\n        // set them the win state\n        if (possibleWin) {\n          emptyCells.clearElements();\n          xAndOs.clearElements();\n          possibleWin.forEach((n) => {\n            gameMatrix[n].markAsWin();\n          });\n\n          // Post the message saying who wins\n          postTextMessage(winMessages[i]);\n\n          // otherwise check if all cells are marked\n        } else if (emptyCells.size === 0) {\n          // Clear elements from the both sets and post the\n          // message that the game is over\n          xAndOs.clearElements();\n          postTextMessage(gameOverMessage);\n        }\n      };\n    })(),\n  );\n\n  // Define the action for the event of 'click' type\n  eventChain({\n    roleSet: set,\n    type: 'click',\n    action() {\n      // Post the message that the cell is occupied\n      postTextMessage(cellMarkedMessage);\n    },\n  });\n\n  return set;\n});\n\n// Add the method that clear both (X and O) RoleSets\nxAndOs.clearElements = function () {\n  this.forEach(set => set.clearElements());\n};\n\n// Define the function that sets the state of a cell and\n// returns the next turn (for X or O)\nfunction setCell(currentTurn, cell) {\n  xAndOs[currentTurn].addElement(cell);\n  return 1 - currentTurn;\n}\n\n// Define the action for the event of 'click' type\neventChain({\n  roleSet: emptyCells,\n  type: 'click',\n  action: ((firstTurn) => {\n    // Store the current turn in closure\n    let currentTurn = firstTurn;\n    return ({ target, roleSet }) => {\n      // Check if the game has just begun and reset the\n      // first turn\n      if (roleSet.size === 9) {\n        currentTurn = firstTurn;\n      }\n      currentTurn = setCell(currentTurn, target);\n    };\n  })(0),\n});\n\n// Define the action that restarts the game\nrestartButton.onclick = () => {\n  // Reset all cells\n  gameMatrix.forEach(cell => cell.resetCell());\n\n  // and add them to the initial RoleSet\n  emptyCells.addElements(gameMatrix);\n};\n</code></pre>","headings":[{"value":"Examples of drama library use","depth":1},{"value":"Example of Tic-tac-toe game","depth":3}],"excerpt":"Examples of drama library use Example of Tic-tac-toe game","frontmatter":{"title":"Examples of drama library use"}}},{"node":{"html":"<h1>Examples of drama library use</h1>\n<h3>Example of Tic-tac-toe game</h3>\n<pre><code class=\"language-javascript\">// Define the class of cells that the board of tic-tac-toe game consists of\nclass Cell {\n  constructor() {\n    this.node = createCell();\n  }\n}\n\n// interpretTarget property of the parameter passed to\n// defineRoutine defines the way to reach the DOM element of\n// event targets\ndefineRoutine({ interpretTarget: e => e.node });\n\n// Define the messages strings\nconst cellMarkedMessage = 'The cell is already set';\nconst gameOverMessage = 'Game is over';\nconst winMessages = ['X won', 'O won'];\n\n// Define the names of methods that mark cells as X and O\nconst turns = ['markX', 'markO'];\n\n// Add methods to the Cell class that mark a cell as X and\n// O, method that marks a cell as a part of a wining line,\n// and one that resets a cell to the empty state\nObject.assign(Cell.prototype, {\n  [turns[0]]: markX,\n  [turns[1]]: markO,\n  markAsWin,\n  resetCell,\n});\n\n// Build the board of the game\nconst gameMatrix = buildMatrix(Cell);\n\n// Define the RoleSet containing empty cells (in the\n// beginning of the game all cells are empty)\nconst emptyCells = new RoleSet(gameMatrix);\n\n// Define a function keeping the record of marked cells (for\n// each type of marks)\nfunction keepState(cell, filledCells) {\n  const cellN = gameMatrix.indexOf(cell);\n  return [...filledCells, cellN].sort((a, b) => a - b);\n}\n\n// Define two empty RoleSet's for X and O\nconst xAndOs = turns.map((turn, i) => {\n  const set = new RoleSet();\n  // Define action for the event when a new element is being\n  // added to RoleSet\n  setActionOnAddElement(\n    set,\n    (() => {\n      // Keep the record of marked cells in closure\n      let filledCells = [];\n      return ({ target, roleSet }) => {\n        // Reset the record when the first element is added\n        if (roleSet.size === 1) {\n          filledCells = [];\n        }\n\n        // Mark the cell\n        target[turn]();\n\n        // Add the cell to the record\n        filledCells = keepState(target, filledCells);\n\n        // Check if the state of win exists\n        const possibleWin = analyzePossibleWin(filledCells);\n\n        // If analyzePossibleWin returns an array of cells\n        // set them the win state\n        if (possibleWin) {\n          emptyCells.clearElements();\n          xAndOs.clearElements();\n          possibleWin.forEach((n) => {\n            gameMatrix[n].markAsWin();\n          });\n\n          // Post the message saying who wins\n          postTextMessage(winMessages[i]);\n\n          // otherwise check if all cells are marked\n        } else if (emptyCells.size === 0) {\n          // Clear elements from the both sets and post the\n          // message that the game is over\n          xAndOs.clearElements();\n          postTextMessage(gameOverMessage);\n        }\n      };\n    })(),\n  );\n\n  // Define the action for the event of 'click' type\n  eventChain({\n    roleSet: set,\n    type: 'click',\n    action() {\n      // Post the message that the cell is occupied\n      postTextMessage(cellMarkedMessage);\n    },\n  });\n\n  return set;\n});\n\n// Add the method that clear both (X and O) RoleSets\nxAndOs.clearElements = function () {\n  this.forEach(set => set.clearElements());\n};\n\n// Define the function that sets the state of a cell and\n// returns the next turn (for X or O)\nfunction setCell(currentTurn, cell) {\n  xAndOs[currentTurn].addElement(cell);\n  return 1 - currentTurn;\n}\n\n// Define the action for the event of 'click' type\neventChain({\n  roleSet: emptyCells,\n  type: 'click',\n  action: ((firstTurn) => {\n    // Store the current turn in closure\n    let currentTurn = firstTurn;\n    return ({ target, roleSet }) => {\n      // Check if the game has just begun and reset the\n      // first turn\n      if (roleSet.size === 9) {\n        currentTurn = firstTurn;\n      }\n      currentTurn = setCell(currentTurn, target);\n    };\n  })(0),\n});\n\n// Define the action that restarts the game\nrestartButton.onclick = () => {\n  // Reset all cells\n  gameMatrix.forEach(cell => cell.resetCell());\n\n  // and add them to the initial RoleSet\n  emptyCells.addElements(gameMatrix);\n};\n</code></pre>","headings":[{"value":"Examples of drama library use","depth":1},{"value":"Example of Tic-tac-toe game","depth":3}],"excerpt":"Examples of drama library use Example of Tic-tac-toe game","frontmatter":{"title":"Examples of drama library use"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}